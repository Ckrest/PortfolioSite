<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Model Evaluation Systems Diagram — Nick Young</title>
  <meta name="description" content="Interactive React component that visualizes an AI model evaluation workflow with tooltips and simulation states." />
  <link rel="stylesheet" href="../project.css" />
</head>
<body>
  <nav class="breadcrumb" aria-label="Breadcrumb">
    <a href="../../index.html">← Back to projects</a>
    <span> / AI Model Evaluation Systems Diagram</span>
  </nav>

  <header>
    <div class="hero" role="presentation">
      <h1>AI Model Evaluation Systems Diagram</h1>
      <p>
        A single-file React component that renders an interactive SVG flowchart for comparing and auditing model evaluation
        pipelines. Tooltips, simulation highlights, and responsive layout are all included with zero external UI dependencies.
      </p>
      <div class="button-row">
        <a class="button" href="../../ai_model_evaluation_systems_diagram" download>Download component</a>
        <a class="button" href="#code">Jump to source</a>
      </div>
    </div>
  </header>

  <main>
    <section class="live-demo">
      <h2>Interactive preview</h2>
      <p>
        Explore the working diagram below. Run the simulation to see how requests move through the evaluation stack,
        surface tooltips for each block, and compare randomized accuracy scores across models in real time.
      </p>
      <div class="diagram-stage">
        <div id="diagram-root" class="diagram-root" aria-live="polite"></div>
      </div>
    </section>

    <section>
      <figure>
        <img src="preview.svg" alt="Stylized preview of the AI evaluation system diagram" loading="lazy" />
      </figure>
      <div class="tag-row">
        <span class="tag">React</span>
        <span class="tag">SVG</span>
        <span class="tag">Tooling</span>
      </div>
    </section>

    <section>
      <h2>What&apos;s inside</h2>
      <p>
        The component organizes evaluation stages into reusable node definitions and wiring logic, then renders an SVG with
        animated highlights. It exposes a lightweight simulation runner for demos and leans on CSS utilities instead of
        external frameworks, keeping bundle size low.
      </p>
      <p>
        Drop it into any React setup (Vite, Next.js, Create React App) and it will render a polished diagram immediately. The
        component is intentionally self-contained, so you can adapt node definitions, colors, or tooltip copy without chasing
        extra files.
      </p>
    </section>

    <section id="code">
      <h2>Source</h2>
      <p>
        The latest version lives alongside this page. Copy it straight from the snippet below or download it if you prefer to
        wire it into your build pipeline manually.
      </p>
      <pre><code id="code-block">Loading component…</code></pre>
    </section>
  </main>

  <footer class="footer">
    <p>© <span id="y"></span> Nick Young. Crafted for rapid prototyping and demos.</p>
  </footer>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    const { useMemo, useRef, useState, useEffect } = React;

    function InfoCard({ title, items }) {
      return (
        <div className="rounded-2xl border p-4 shadow-sm">
          <div className="mb-1 text-sm font-semibold">{title}</div>
          <ul className="list-disc pl-5 text-sm text-gray-700">
            {items.map((it, i) => (
              <li key={i}>{it}</li>
            ))}
          </ul>
        </div>
      );
    }

    function InteractiveAIEvalFlowchart() {
      const W = 1100;
      const H = 820;

      const nodeBase = {
        w: 180,
        h: 64,
        rx: 16,
      };

      const nodes = useMemo(
        () => [
          {
            id: "inputs",
            label: "Inputs",
            x: 120,
            y: 110,
            w: 160,
            h: 60,
            tip: "Raw test material: images, text, audio, etc. Each item is a test unit with an ID and metadata.",
          },
          {
            id: "pre",
            label: "Data Preprocessor",
            x: 340,
            y: 110,
            w: 220,
            h: 60,
            tip: "Normalizes inputs, validates schemas, and attaches ground-truth labels if known.",
          },
          {
            id: "dist",
            label: "Task Distributor",
            x: 620,
            y: 110,
            w: 220,
            h: 60,
            tip: "Fan-out dispatcher that guarantees all models get the same inputs and task prompts.",
          },
          {
            id: "mA",
            label: "Model A",
            x: 250,
            y: 270,
            w: 140,
            h: 60,
            tip: "First contender. Could be a specific model + prompt preset.",
          },
          {
            id: "mB",
            label: "Model B",
            x: 420,
            y: 270,
            w: 140,
            h: 60,
            tip: "Second contender with different settings, tools, or context window.",
          },
          {
            id: "mC",
            label: "Model C",
            x: 590,
            y: 270,
            w: 140,
            h: 60,
            tip: "Third contender. Same task, variant strategy.",
          },
          {
            id: "mD",
            label: "Model D",
            x: 760,
            y: 270,
            w: 140,
            h: 60,
            tip: "Fourth contender. Maybe vision-enabled or tool-using.",
          },
          {
            id: "mE",
            label: "Model E",
            x: 930,
            y: 270,
            w: 140,
            h: 60,
            tip: "Fifth contender. Baseline or a control.",
          },
          {
            id: "collector",
            label: "Result Collector",
            x: 620,
            y: 430,
            ...nodeBase,
            tip: "Normalizes raw outputs: { model_id, input_id, response, confidence, latency }.",
          },
          {
            id: "overseer",
            label: "Overseer AI",
            x: 620,
            y: 570,
            ...nodeBase,
            tip: "Judges against ground truth or reference policies; computes accuracy and consistency.",
          },
          {
            id: "metrics",
            label: "Metrics / Reports",
            x: 620,
            y: 710,
            ...nodeBase,
            tip: "Leaderboards, failure clusters, confusion matrices, and exportable summaries.",
          },
        ],
        []
      );

      const nodeMap = useMemo(() => Object.fromEntries(nodes.map((n) => [n.id, n])), [nodes]);

      const getPorts = (from, to) => {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const horiz = Math.abs(dx) >= Math.abs(dy);

        const start = { x: from.x + Math.sign(dx) * (from.w / 2), y: from.y };
        const end = { x: to.x - Math.sign(dx) * (to.w / 2), y: to.y };

        if (!horiz) {
          const sy = from.y + Math.sign(dy) * (from.h / 2);
          const ey = to.y - Math.sign(dy) * (to.h / 2);
          return { start: { x: from.x, y: sy }, end: { x: to.x, y: ey } };
        }
        return { start, end };
      };

      const edges = useMemo(() => {
        const e = [];
        const add = (a, b) => e.push({ id: `${a}->${b}`, from: a, to: b });

        add("inputs", "pre");
        add("pre", "dist");
        ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add("dist", m));
        ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add(m, "collector"));
        add("collector", "overseer");
        add("overseer", "metrics");
        return e;
      }, []);

      const [hovered, setHovered] = useState(null);
      const [activeNodes, setActiveNodes] = useState(new Set());
      const [activeEdges, setActiveEdges] = useState(new Set());
      const [packets, setPackets] = useState([]);
      const [modelScores, setModelScores] = useState({});
      const [isRunning, setIsRunning] = useState(false);

      const containerRef = useRef(null);

      const highlightNode = (id, on = true) => {
        setActiveNodes((prev) => {
          const n = new Set(prev);
          if (on) n.add(id);
          else n.delete(id);
          return n;
        });
      };

      const highlightEdge = (id, on = true) => {
        setActiveEdges((prev) => {
          const n = new Set(prev);
          if (on) n.add(id);
          else n.delete(id);
          return n;
        });
      };

      const reset = () => {
        setActiveNodes(new Set());
        setActiveEdges(new Set());
        setPackets([]);
        setModelScores({});
      };

      const wait = (ms) => new Promise((res) => setTimeout(res, ms));

      const spawnPacket = (fromId, toId, duration = 800, delay = 0) => {
        const from = nodeMap[fromId];
        const to = nodeMap[toId];
        const { start, end } = getPorts(from, to);
        const id = `${fromId}>${toId}>${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;

        setTimeout(() => {
          setPackets((prev) => [
            ...prev,
            {
              id,
              x: start.x,
              y: start.y,
              toX: end.x,
              toY: end.y,
              progress: 0,
              duration,
              startTime: performance.now(),
            },
          ]);
        }, delay);
      };

      useEffect(() => {
        let raf;
        const tick = (t) => {
          setPackets((prev) => {
            const next = [];
            for (const p of prev) {
              const elapsed = t - p.startTime;
              const done = elapsed >= p.duration;
              const prog = Math.min(1, Math.max(0, elapsed / p.duration));
              const x = p.x + (p.toX - p.x) * prog;
              const y = p.y + (p.toY - p.y) * prog;
              if (!done) next.push({ ...p, progress: prog, curX: x, curY: y });
            }
            return next;
          });
          raf = requestAnimationFrame(tick);
        };
        raf = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(raf);
      }, []);

      const run = async () => {
        if (isRunning) return;
        setIsRunning(true);
        reset();

        highlightNode("inputs");
        spawnPacket("inputs", "pre", 800, 150);
        highlightEdge("inputs->pre", true);
        await wait(1000);

        highlightNode("pre");
        highlightEdge("pre->dist", true);
        spawnPacket("pre", "dist", 800, 120);
        await wait(900);

        highlightNode("dist");

        const models = ["mA", "mB", "mC", "mD", "mE"];
        models.forEach((m, i) => {
          highlightEdge(`dist->${m}`, true);
          spawnPacket("dist", m, 700, i * 120);
        });
        await wait(120 * models.length + 850);

        models.forEach((m) => highlightNode(m));

        models.forEach((m, i) => {
          highlightEdge(`${m}->collector`, true);
          spawnPacket(m, "collector", 700, i * 120);
        });
        await wait(120 * models.length + 850);

        highlightNode("collector");

        const rng = (seed) => {
          let x = Math.imul(seed ^ 0x9e3779b9, 0x85ebca6b) >>> 0;
          return () => ((x = (x ^ (x << 13)) ^ (x >>> 17) ^ (x << 5)) >>> 0) / 2 ** 32;
        };
        const r = rng(Date.now() & 0xffff);
        const scores = Object.fromEntries(models.map((m) => [m, Math.round(70 + r() * 28)]));
        setModelScores(scores);

        highlightEdge("collector->overseer", true);
        spawnPacket("collector", "overseer", 800, 50);
        await wait(900);

        highlightNode("overseer");
        highlightEdge("overseer->metrics", true);
        spawnPacket("overseer", "metrics", 800, 50);
        await wait(900);

        highlightNode("metrics");

        setIsRunning(false);
      };

      const bestModel = useMemo(() => {
        const entries = Object.entries(modelScores);
        if (!entries.length) return null;
        return entries.reduce((a, b) => (a[1] >= b[1] ? a : b));
      }, [modelScores]);

      function Tooltip({ node }) {
        if (!node) return null;
        const pad = 10;
        const left = Math.min(W - 280, Math.max(16, node.x - node.w / 2));
        const top = Math.max(16, node.y - node.h / 2 - 64);
        return (
          <div className="pointer-events-none absolute z-20 max-w-[260px] rounded-xl border bg-white/95 p-3 text-sm shadow-xl" style={{ left: left + pad, top: top }}>
            <div className="font-medium mb-1 text-gray-800">{node.label}</div>
            <div className="text-gray-600">{node.tip}</div>
          </div>
        );
      }

      const renderNode = (n) => {
        const active = activeNodes.has(n.id);
        const score = modelScores[n.id];
        return (
          <g
            key={n.id}
            className="cursor-pointer"
            onMouseEnter={() => setHovered(n.id)}
            onMouseLeave={() => setHovered((h) => (h === n.id ? null : h))}
          >
            <rect
              x={n.x - n.w / 2}
              y={n.y - n.h / 2}
              rx={16}
              width={n.w}
              height={n.h}
              fill={active ? "#eef2ff" : "#ffffff"}
              stroke={active ? "#4f46e5" : "#cbd5e1"}
              strokeWidth={active ? 2.4 : 1.4}
              className="transition-all"
            />
            <text
              x={n.x}
              y={n.y}
              textAnchor="middle"
              dominantBaseline="central"
              className="select-none fill-gray-800 text-[14px] font-medium"
            >
              {n.label}
            </text>
            {typeof score === "number" && (
              <text
                x={n.x}
                y={n.y + n.h / 2 + 16}
                textAnchor="middle"
                className="select-none fill-gray-600 text-[12px]"
              >
                Acc: {score}%
              </text>
            )}
          </g>
        );
      };

      const renderEdge = (e) => {
        const from = nodeMap[e.from];
        const to = nodeMap[e.to];
        const { start, end } = getPorts(from, to);
        const active = activeEdges.has(e.id);
        return (
          <g key={e.id}>
            <line
              x1={start.x}
              y1={start.y}
              x2={end.x}
              y2={end.y}
              stroke={active ? "#4f46e5" : "#94a3b8"}
              strokeWidth={active ? 2.6 : 1.6}
              markerEnd="url(#arrow)"
              className="transition-all"
            />
          </g>
        );
      };

      return (
        <div ref={containerRef} className="w-full flex items-center justify-center p-6">
          <div className="w-full max-w-[1200px] rounded-2xl border bg-white p-5 shadow-2xl">
            <div className="mb-4 flex items-center justify-between">
              <div className="text-xl font-semibold text-gray-800">AI Evaluation Framework — Interactive Flow</div>
              <div className="flex items-center gap-3">
                {bestModel && (
                  <div className="rounded-xl bg-gray-50 px-3 py-1 text-sm text-gray-700 border">
                    Best this run: <span className="font-semibold">{nodeMap[bestModel[0]].label}</span> ({bestModel[1]}%)
                  </div>
                )}
                <button
                  onClick={run}
                  disabled={isRunning}
                  className="rounded-2xl border px-4 py-2 text-sm font-medium shadow hover:shadow-md disabled:opacity-60"
                >
                  {isRunning ? "Running…" : "Run Simulation"}
                </button>
              </div>
            </div>

            <div className="relative">
              <Tooltip node={hovered ? nodeMap[hovered] : null} />

              <svg viewBox={`0 0 ${W} ${H}`} width="100%" height="auto">
                <defs>
                  <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
                  </marker>
                </defs>

                {edges.map(renderEdge)}
                {nodes.map(renderNode)}
                {packets.map((p) => (
                  <circle key={p.id} cx={p.curX ?? p.x} cy={p.curY ?? p.y} r={6} fill="#4f46e5" />
                ))}
              </svg>
            </div>

            <div className="mt-4 grid grid-cols-1 gap-3 md:grid-cols-3">
              <InfoCard
                title="How it flows"
                items={[
                  "Inputs are normalized and fanned out to every model.",
                  "Each model returns a response; collector standardizes the format.",
                  "Overseer computes metrics; reports surface winners and failure modes.",
                ]}
              />

              <InfoCard
                title="What to hover"
                items={[
                  "Hover any block to get a definition.",
                  "Run again to get fresh (fake) scores.",
                  "Yes, the arrowheads are judging you.",
                ]}
              />

              <InfoCard
                title="What the demo simulates"
                items={[
                  "Packet travel along edges (staggered fan-out).",
                  "Highlighting of active nodes/edges.",
                  "Randomized accuracy % per model (non-deterministic).",
                ]}
              />
            </div>
          </div>
        </div>
      );
    }

    const rootEl = document.getElementById("diagram-root");
    if (rootEl) {
      const root = ReactDOM.createRoot(rootEl);
      root.render(<InteractiveAIEvalFlowchart />);
    }
  </script>
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    async function loadSource() {
      const el = document.getElementById('code-block');
      try {
        const res = await fetch('../../ai_model_evaluation_systems_diagram');
        if (!res.ok) throw new Error('Request failed');
        const text = await res.text();
        el.textContent = text;
      } catch (err) {
        el.textContent = 'Unable to load source. Try downloading the file instead.';
      }
    }
    loadSource();
  </script>
</body>
</html>
