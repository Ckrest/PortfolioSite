import React, { useMemo, useRef, useState, useEffect, useCallback } from "react";

// Interactive, single-file React component that renders an AI evaluation
// system diagram with tooltips and a simple "simulation" runner.
// Uses only React + Tailwind classes (no external UI libs).
// Drop into any React app (Next.js, Vite, CRA). Default export below.

export default function InteractiveAIEvalFlowchart() {
  // --- Layout constants (SVG coordinates) ---
  const W = 1100;
  const H = 820;

  const nodeBase = {
    w: 180,
    h: 64,
    rx: 16,
  };

  // Define nodes with center-based coordinates
  const nodes = useMemo(
    () => ([
      {
        id: "inputs",
        label: "Inputs",
        x: 120,
        y: 110,
        w: 160,
        h: 60,
        tip: "Raw test material: images, text, audio, etc. Each item is a test unit with an ID and metadata.",
      },
      {
        id: "pre",
        label: "Data Preprocessor",
        x: 340,
        y: 110,
        w: 220,
        h: 60,
        tip: "Normalizes inputs, validates schemas, and attaches ground-truth labels if known.",
      },
      {
        id: "dist",
        label: "Task Distributor",
        x: 620,
        y: 110,
        w: 220,
        h: 60,
        tip: "Fan-out dispatcher that guarantees all models get the same inputs and task prompts.",
      },
      // Models row
      {
        id: "mA",
        label: "Model A",
        x: 250,
        y: 270,
        w: 140,
        h: 60,
        tip: "First contender. Could be a specific model + prompt preset.",
      },
      {
        id: "mB",
        label: "Model B",
        x: 420,
        y: 270,
        w: 140,
        h: 60,
        tip: "Second contender with different settings, tools, or context window.",
      },
      {
        id: "mC",
        label: "Model C",
        x: 590,
        y: 270,
        w: 140,
        h: 60,
        tip: "Third contender. Same task, variant strategy.",
      },
      {
        id: "mD",
        label: "Model D",
        x: 760,
        y: 270,
        w: 140,
        h: 60,
        tip: "Fourth contender. Maybe vision-enabled or tool-using.",
      },
      {
        id: "mE",
        label: "Model E",
        x: 930,
        y: 270,
        w: 140,
        h: 60,
        tip: "Fifth contender. Baseline or a control.",
      },
      {
        id: "collector",
        label: "Result Collector",
        x: 620,
        y: 430,
        ...nodeBase,
        tip: "Normalizes raw outputs: { model_id, input_id, response, confidence, latency }.",
      },
      {
        id: "overseer",
        label: "Overseer AI",
        x: 620,
        y: 570,
        ...nodeBase,
        tip: "Judges against ground truth or reference policies; computes accuracy and consistency.",
      },
      {
        id: "metrics",
        label: "Metrics / Reports",
        x: 620,
        y: 710,
        ...nodeBase,
        tip: "Leaderboards, failure clusters, confusion matrices, and exportable summaries.",
      },
    ]),
    []
  );

  const nodeMap = useMemo(() => Object.fromEntries(nodes.map((n) => [n.id, n])), [nodes]);

  const rowBands = useMemo(
    () => [
      { id: "intake", y: 40, h: 150, label: "Intake & Routing" },
      { id: "models", y: 200, h: 140, label: "Model Responses" },
      { id: "judging", y: 360, h: 160, label: "Scoring & Oversight" },
      { id: "reporting", y: 540, h: 180, label: "Reporting" },
    ],
    []
  );

  // Utility to pick a good connection port based on relative position
  const getPorts = (from, to) => {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const horiz = Math.abs(dx) >= Math.abs(dy);

    const start = { x: from.x + Math.sign(dx) * (from.w / 2), y: from.y };
    const end = { x: to.x - Math.sign(dx) * (to.w / 2), y: to.y };

    // If mostly vertical, use bottom/top ports
    if (!horiz) {
      const sy = from.y + Math.sign(dy) * (from.h / 2);
      const ey = to.y - Math.sign(dy) * (to.h / 2);
      return { start: { x: from.x, y: sy }, end: { x: to.x, y: ey } };
    }
    return { start, end };
  };

  // Edges in the graph
  const edges = useMemo(() => {
    const e = [];
    const add = (a, b) => e.push({ id: `${a}->${b}`, from: a, to: b });

    add("inputs", "pre");
    add("pre", "dist");
    ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add("dist", m));
    ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add(m, "collector"));
    add("collector", "overseer");
    add("overseer", "metrics");
    return e;
  }, []);

  // Hover tooltip state
  const [hovered, setHovered] = useState(null); // node id

  // Active highlighting during simulation
  const [activeNodes, setActiveNodes] = useState(new Set());
  const [activeEdges, setActiveEdges] = useState(new Set());
  const [activeRow, setActiveRow] = useState(null);

  // Packets (animated markers) traveling along edges
  const [packets, setPackets] = useState([]);

  // Model metrics to display after evaluation step
  const [modelScores, setModelScores] = useState({});
  const [isRunning, setIsRunning] = useState(false);
  const [story, setStory] = useState([]);
  const [caseStage, setCaseStage] = useState("idle");

  const exampleCase = useMemo(
    () => ({
      id: "Case #347",
      prompt: "Instruction: Sum the digits 1 + 1 + 1 and respond with a numeral.",
      expected: "Correct answer: 3",
    }),
    []
  );

  const pushStory = useCallback((entry) => {
    setStory((prev) => [
      ...prev,
      {
        id: `${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
        ...entry,
      },
    ]);
  }, []);

  const containerRef = useRef(null);

  const highlightNode = (id, on = true) => {
    setActiveNodes((prev) => {
      const n = new Set(prev);
      if (on) n.add(id);
      else n.delete(id);
      return n;
    });
  };

  const highlightEdge = (id, on = true) => {
    setActiveEdges((prev) => {
      const n = new Set(prev);
      if (on) n.add(id);
      else n.delete(id);
      return n;
    });
  };

  const reset = () => {
    setActiveNodes(new Set());
    setActiveEdges(new Set());
    setActiveRow(null);
    setPackets([]);
    setModelScores({});
    setStory([]);
    setCaseStage("idle");
  };

  // Utility delay
  const wait = (ms) => new Promise((res) => setTimeout(res, ms));

  // Create a moving packet between two nodes
  const spawnPacket = (fromId, toId, options = {}) => {
    const { duration = 1400, delay = 0, label = null } = options;
    const from = nodeMap[fromId];
    const to = nodeMap[toId];
    const { start, end } = getPorts(from, to);
    const id = `${fromId}>${toId}>${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
    const labelWidth = label ? Math.max(44, label.length * 7 + 18) : null;

    setTimeout(() => {
      setPackets((prev) => [
        ...prev,
        {
          id,
          x: start.x,
          y: start.y,
          toX: end.x,
          toY: end.y,
          progress: 0,
          duration,
          startTime: performance.now(),
          label,
          labelWidth,
        },
      ]);
    }, delay);
  };

  // Animate packets
  useEffect(() => {
    let raf;
    const tick = (t) => {
      setPackets((prev) => {
        const next = [];
        for (const p of prev) {
          const elapsed = t - p.startTime;
          const done = elapsed >= p.duration;
          const prog = Math.min(1, Math.max(0, elapsed / p.duration));
          const x = p.x + (p.toX - p.x) * prog;
          const y = p.y + (p.toY - p.y) * prog;
          if (!done) next.push({ ...p, progress: prog, curX: x, curY: y });
        }
        return next;
      });
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, []);

  // Simulation orchestrator
  const run = async () => {
    if (isRunning) return;
    setIsRunning(true);
    reset();

    const models = ["mA", "mB", "mC", "mD", "mE"];

    setCaseStage("incoming");
    setActiveRow("intake");
    pushStory({
      title: "Incoming evaluation case",
      body: `${exampleCase.id} joins the queue with expected result "${exampleCase.expected}".`,
    });
    await wait(1200);

    setCaseStage("revealed");
    highlightNode("inputs");
    highlightEdge("inputs->pre", true);
    spawnPacket("inputs", "pre", { duration: 1700, delay: 250, label: exampleCase.id });
    pushStory({
      title: "Inputs capture the prompt",
      body: "The request and rubric travel to the data preprocessor.",
    });
    await wait(1900);

    highlightNode("pre");
    highlightEdge("pre->dist", true);
    spawnPacket("pre", "dist", { duration: 1700, delay: 200, label: "Rubric ✓" });
    pushStory({
      title: "Preprocessor normalizes",
      body: `Metadata is validated and the rubric "${exampleCase.expected}" is attached.`,
    });
    await wait(1800);

    setCaseStage("fanout");
    highlightNode("dist");
    setActiveRow("models");
    pushStory({
      title: "Distributor clones the task",
      body: "Every candidate model receives the same prompt and rubric.",
    });

    models.forEach((m, i) => {
      highlightEdge(`dist->${m}`, true);
      spawnPacket("dist", m, {
        duration: 1600,
        delay: i * 260,
        label: nodeMap[m].label,
      });
    });
    await wait(260 * models.length + 1900);

    models.forEach((m) => highlightNode(m));
    pushStory({
      title: "Models craft responses",
      body: "Each system proposes an answer to the math instruction.",
    });

    models.forEach((m, i) => {
      highlightEdge(`${m}->collector`, true);
      spawnPacket(m, "collector", { duration: 1700, delay: i * 260, label: "Answer" });
    });
    await wait(260 * models.length + 1900);

    setCaseStage("scoring");
    setActiveRow("judging");
    highlightNode("collector");
    pushStory({
      title: "Collector packages outputs",
      body: "Responses are standardized with latency and confidence fields.",
    });

    const rng = (seed) => {
      let x = Math.imul(seed ^ 0x9e3779b9, 0x85ebca6b) >>> 0;
      return () => ((x = (x ^ (x << 13)) ^ (x >>> 17) ^ (x << 5)) >>> 0) / 2 ** 32;
    };
    const r = rng(Date.now() & 0xffff);
    const scores = Object.fromEntries(models.map((m) => [m, Math.round(70 + r() * 28)]));
    setModelScores(scores);

    highlightEdge("collector->overseer", true);
    spawnPacket("collector", "overseer", { duration: 1700, delay: 150, label: "Score batch" });
    pushStory({
      title: "Overseer ready to judge",
      body: `Ground truth "${exampleCase.expected}" is compared to each response.`,
    });
    await wait(1900);

    highlightNode("overseer");

    const winner = Object.entries(scores).reduce((a, b) => (a[1] >= b[1] ? a : b));

    highlightEdge("overseer->metrics", true);
    spawnPacket("overseer", "metrics", { duration: 1700, delay: 160, label: "Report" });
    setCaseStage("reporting");
    setActiveRow("reporting");
    pushStory({
      title: "Reports refreshed",
      body: `${nodeMap[winner[0]].label} leads this run with ${winner[1]}% accuracy.`,
    });
    await wait(1900);

    highlightNode("metrics");
    setCaseStage("complete");

    setIsRunning(false);
  };

  const bestModel = useMemo(() => {
    const entries = Object.entries(modelScores);
    if (!entries.length) return null;
    return entries.reduce((a, b) => (a[1] >= b[1] ? a : b));
  }, [modelScores]);

  // Tooltip component
  function Tooltip({ node }) {
    if (!node) return null;
    const pad = 10;
    const left = Math.min(W - 280, Math.max(16, node.x - node.w / 2));
    const top = Math.max(16, node.y - node.h / 2 - 8 - 56);
    return (
      <div
        className="pointer-events-none absolute z-20 max-w-[260px] rounded-xl border bg-white/95 p-3 text-sm shadow-xl"
        style={{ left: left + pad, top: top }}
      >
        <div className="font-medium mb-1">{node.label}</div>
        <div className="text-gray-600">{node.tip}</div>
      </div>
    );
  }

  // Node visual
  const renderNode = (n) => {
    const active = activeNodes.has(n.id);
    const score = modelScores[n.id];
    return (
      <g
        key={n.id}
        className="cursor-pointer"
        onMouseEnter={() => setHovered(n.id)}
        onMouseLeave={() => setHovered((h) => (h === n.id ? null : h))}
      >
        <rect
          x={n.x - n.w / 2}
          y={n.y - n.h / 2}
          rx={16}
          width={n.w}
          height={n.h}
          fill={active ? "#eef2ff" : "#ffffff"}
          stroke={active ? "#4f46e5" : "#cbd5e1"}
          strokeWidth={active ? 2.4 : 1.4}
          className="transition-all"
        />
        <text
          x={n.x}
          y={n.y}
          textAnchor="middle"
          dominantBaseline="central"
          className="select-none fill-gray-800 text-[14px] font-medium"
        >
          {n.label}
        </text>
        {typeof score === "number" && (
          <text
            x={n.x}
            y={n.y + n.h / 2 + 16}
            textAnchor="middle"
            className="select-none fill-gray-600 text-[12px]"
          >
            Acc: {score}%
          </text>
        )}
      </g>
    );
  };

  const renderEdge = (e) => {
    const from = nodeMap[e.from];
    const to = nodeMap[e.to];
    const { start, end } = getPorts(from, to);
    const active = activeEdges.has(e.id);
    return (
      <g key={e.id}>
        <line
          x1={start.x}
          y1={start.y}
          x2={end.x}
          y2={end.y}
          stroke={active ? "#4f46e5" : "#94a3b8"}
          strokeWidth={active ? 2.6 : 1.6}
          markerEnd="url(#arrow)"
          className="transition-all"
        />
      </g>
    );
  };

  return (
    <div ref={containerRef} className="w-full flex items-center justify-center p-6">
      <div className="w-full max-w-[1200px] rounded-2xl border bg-white p-5 shadow-2xl">
        <div className="mb-4 flex items-center justify-between">
          <div className="text-xl font-semibold">AI Evaluation Framework – Interactive Flow</div>
          <div className="flex items-center gap-3">
            {bestModel && (
              <div className="rounded-xl bg-gray-50 px-3 py-1 text-sm text-gray-700 border">
                Best this run: <span className="font-semibold">{nodeMap[bestModel[0]].label}</span> ({bestModel[1]}%)
              </div>
            )}
            <button
              onClick={run}
              disabled={isRunning}
              className="rounded-2xl border px-4 py-2 text-sm font-medium shadow hover:shadow-md disabled:opacity-60"
            >
              {isRunning ? "Running…" : "Run Simulation"}
            </button>
          </div>
        </div>

        <div className="relative">
          {/* Tooltip */}
          <Tooltip node={hovered ? nodeMap[hovered] : null} />

          <svg viewBox={`0 0 ${W} ${H}`} width="100%" height="auto">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
              </marker>
            </defs>

            {/* Row bands */}
            {rowBands.map((band) => (
              <g key={band.id}>
                <rect
                  x={60}
                  y={band.y}
                  width={W - 120}
                  height={band.h}
                  rx={32}
                  fill={activeRow === band.id ? "#e0e7ff" : "#f1f5f9"}
                  opacity={activeRow === band.id ? 0.5 : 0.18}
                />
                <text
                  x={80}
                  y={band.y + 24}
                  className="select-none fill-slate-500 text-[12px] tracking-wide"
                >
                  {band.label}
                </text>
              </g>
            ))}

            {/* Edges underneath */}
            {edges.map(renderEdge)}

            {/* Nodes on top */}
            {nodes.map(renderNode)}

            {/* Packets */}
            {packets.map((p) => {
              const x = p.curX ?? p.x;
              const y = p.curY ?? p.y;
              if (p.label) {
                const w = p.labelWidth ?? 48;
                const h = 26;
                return (
                  <g key={p.id}>
                    <rect
                      x={x - w / 2}
                      y={y - h / 2}
                      width={w}
                      height={h}
                      rx={10}
                      fill="#4f46e5"
                      fillOpacity={0.92}
                      stroke="#312e81"
                      strokeWidth={1}
                    />
                    <text
                      x={x}
                      y={y + 4}
                      textAnchor="middle"
                      className="select-none fill-white text-[11px]"
                    >
                      {p.label}
                    </text>
                  </g>
                );
              }
              return <circle key={p.id} cx={x} cy={y} r={6} fill="#4f46e5" />;
            })}
          </svg>
        </div>

        <ScenarioPanel
          caseStage={caseStage}
          exampleCase={exampleCase}
          story={story}
          isRunning={isRunning}
        />

        <div className="mt-4 grid grid-cols-1 gap-3 md:grid-cols-3">
          <InfoCard title="How it flows" items={[
            "Inputs are normalized and fanned out to every model.",
            "Each model returns a response; collector standardizes the format.",
            "Overseer computes metrics; reports surface winners and failure modes.",
          ]} />

          <InfoCard title="What to hover" items={[
            "Hover any block to get a definition.",
            "Run again to get fresh (fake) scores.",
            "Yes, the arrowheads are judging you.",
          ]} />

          <InfoCard title="What the demo simulates" items={[
            "Packet travel along edges (staggered fan-out).",
            "Highlighting of active nodes/edges.",
            "Randomized accuracy % per model (non-deterministic).",
          ]} />
        </div>
      </div>
    </div>
  );
}

function ScenarioPanel({ caseStage, exampleCase, story, isRunning }) {
  const stageCopy = {
    idle: {
      status: "Idle",
      detail: "Press \"Run Simulation\" to watch the sample case travel the system.",
    },
    incoming: {
      status: "Incoming…",
      detail: "Queuing the test item before preprocessing begins.",
      dots: true,
    },
    revealed: {
      status: "Normalizing",
      detail: "Cleaning the prompt and attaching the reference answer.",
    },
    fanout: {
      status: "Fan-out",
      detail: "Distributor is cloning the task for each model.",
    },
    scoring: {
      status: "Scoring",
      detail: "Collector and overseer are comparing responses to the rubric.",
    },
    reporting: {
      status: "Reporting",
      detail: "Publishing the updated leaderboard and metrics.",
    },
    complete: {
      status: "Finished",
      detail: "Reports and dashboards updated with the latest metrics.",
    },
  };

  const currentStage = stageCopy[caseStage] ?? stageCopy.idle;

  return (
    <div className="mt-6 flex flex-col gap-4 rounded-2xl border bg-slate-50/60 p-4 shadow-inner md:flex-row md:items-start md:gap-6">
      <div className="w-full rounded-2xl border border-indigo-200 bg-indigo-50/70 p-4 text-indigo-900 md:w-72">
        <div className="text-xs font-semibold uppercase tracking-wide text-indigo-600">Example evaluation case</div>
        <div className="mt-2 text-sm font-semibold">{exampleCase.prompt}</div>
        <div className="mt-2 text-sm">
          Expected outcome: <span className="font-semibold">{exampleCase.expected}</span>
        </div>
        <div className="mt-3 rounded-xl border border-indigo-200 bg-white/70 px-3 py-2 text-xs text-indigo-800">
          <div className="font-semibold">{currentStage.status}</div>
          <div className="mt-1 text-[11px] text-indigo-700">{currentStage.detail}</div>
          {currentStage.dots && (
            <div className="mt-2 flex items-center gap-1 text-base leading-none text-indigo-500">
              <span className="animate-pulse">•</span>
              <span className="animate-pulse [animation-delay:120ms]">•</span>
              <span className="animate-pulse [animation-delay:240ms]">•</span>
            </div>
          )}
        </div>
      </div>

      <div className="flex-1 rounded-2xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="text-sm font-semibold text-slate-800">Simulation log</div>
          {isRunning && <div className="text-xs font-medium text-indigo-600">Playing…</div>}
        </div>
        <ol className="mt-3 space-y-3 text-sm text-slate-700">
          {story.length === 0 && (
            <li className="rounded-xl border border-dashed border-slate-300 bg-slate-50/80 px-3 py-3 text-slate-500">
              Kick things off by pressing the run button above.
            </li>
          )}
          {story.map((step, idx) => (
            <li
              key={step.id}
              className="rounded-xl border border-slate-200 bg-slate-50/70 px-3 py-2 shadow-sm"
            >
              <div className="text-[11px] font-semibold uppercase tracking-wide text-slate-500">
                Step {idx + 1}
              </div>
              <div className="text-sm font-semibold text-slate-900">{step.title}</div>
              <div className="text-sm text-slate-700">{step.body}</div>
            </li>
          ))}
        </ol>
      </div>
    </div>
  );
}

function InfoCard({ title, items }) {
  return (
    <div className="rounded-2xl border p-4 shadow-sm">
      <div className="mb-1 text-sm font-semibold">{title}</div>
      <ul className="list-disc pl-5 text-sm text-gray-700">
        {items.map((it, i) => (
          <li key={i}>{it}</li>
        ))}
      </ul>
    </div>
  );
}
