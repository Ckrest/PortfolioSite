import React, { useMemo, useRef, useState, useEffect } from "react";

// Interactive, single-file React component that renders an AI evaluation
// system diagram with tooltips and a simple "simulation" runner.
// Uses only React + Tailwind classes (no external UI libs).
// Drop into any React app (Next.js, Vite, CRA). Default export below.

export default function InteractiveAIEvalFlowchart() {
  // --- Layout constants (SVG coordinates) ---
  const W = 1100;
  const H = 820;

  const nodeBase = {
    w: 180,
    h: 64,
    rx: 16,
  };

  // Define nodes with center-based coordinates
  const nodes = useMemo(
    () => ([
      {
        id: "inputs",
        label: "Inputs",
        x: 120,
        y: 110,
        w: 160,
        h: 60,
        tip: "Raw test material: images, text, audio, etc. Each item is a test unit with an ID and metadata.",
      },
      {
        id: "pre",
        label: "Data Preprocessor",
        x: 340,
        y: 110,
        w: 220,
        h: 60,
        tip: "Normalizes inputs, validates schemas, and attaches ground-truth labels if known.",
      },
      {
        id: "dist",
        label: "Task Distributor",
        x: 620,
        y: 110,
        w: 220,
        h: 60,
        tip: "Fan-out dispatcher that guarantees all models get the same inputs and task prompts.",
      },
      // Models row
      {
        id: "mA",
        label: "Model A",
        x: 250,
        y: 270,
        w: 140,
        h: 60,
        tip: "First contender. Could be a specific model + prompt preset.",
      },
      {
        id: "mB",
        label: "Model B",
        x: 420,
        y: 270,
        w: 140,
        h: 60,
        tip: "Second contender with different settings, tools, or context window.",
      },
      {
        id: "mC",
        label: "Model C",
        x: 590,
        y: 270,
        w: 140,
        h: 60,
        tip: "Third contender. Same task, variant strategy.",
      },
      {
        id: "mD",
        label: "Model D",
        x: 760,
        y: 270,
        w: 140,
        h: 60,
        tip: "Fourth contender. Maybe vision-enabled or tool-using.",
      },
      {
        id: "mE",
        label: "Model E",
        x: 930,
        y: 270,
        w: 140,
        h: 60,
        tip: "Fifth contender. Baseline or a control.",
      },
      {
        id: "collector",
        label: "Result Collector",
        x: 620,
        y: 430,
        ...nodeBase,
        tip: "Normalizes raw outputs: { model_id, input_id, response, confidence, latency }.",
      },
      {
        id: "overseer",
        label: "Overseer AI",
        x: 620,
        y: 570,
        ...nodeBase,
        tip: "Judges against ground truth or reference policies; computes accuracy and consistency.",
      },
      {
        id: "metrics",
        label: "Metrics / Reports",
        x: 620,
        y: 710,
        ...nodeBase,
        tip: "Leaderboards, failure clusters, confusion matrices, and exportable summaries.",
      },
    ]),
    []
  );

  const nodeMap = useMemo(() => Object.fromEntries(nodes.map((n) => [n.id, n])), [nodes]);

  // Utility to pick a good connection port based on relative position
  const getPorts = (from, to) => {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const horiz = Math.abs(dx) >= Math.abs(dy);

    const start = { x: from.x + Math.sign(dx) * (from.w / 2), y: from.y };
    const end = { x: to.x - Math.sign(dx) * (to.w / 2), y: to.y };

    // If mostly vertical, use bottom/top ports
    if (!horiz) {
      const sy = from.y + Math.sign(dy) * (from.h / 2);
      const ey = to.y - Math.sign(dy) * (to.h / 2);
      return { start: { x: from.x, y: sy }, end: { x: to.x, y: ey } };
    }
    return { start, end };
  };

  // Edges in the graph
  const edges = useMemo(() => {
    const e = [];
    const add = (a, b) => e.push({ id: `${a}->${b}`, from: a, to: b });

    add("inputs", "pre");
    add("pre", "dist");
    ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add("dist", m));
    ["mA", "mB", "mC", "mD", "mE"].forEach((m) => add(m, "collector"));
    add("collector", "overseer");
    add("overseer", "metrics");
    return e;
  }, []);

  // Hover tooltip state
  const [hovered, setHovered] = useState(null); // node id

  // Active highlighting during simulation
  const [activeNodes, setActiveNodes] = useState(new Set());
  const [activeEdges, setActiveEdges] = useState(new Set());

  // Packets (animated markers) traveling along edges
  const [packets, setPackets] = useState([]);

  // Model metrics to display after evaluation step
  const [modelScores, setModelScores] = useState({});
  const [isRunning, setIsRunning] = useState(false);

  const containerRef = useRef(null);

  const highlightNode = (id, on = true) => {
    setActiveNodes((prev) => {
      const n = new Set(prev);
      if (on) n.add(id);
      else n.delete(id);
      return n;
    });
  };

  const highlightEdge = (id, on = true) => {
    setActiveEdges((prev) => {
      const n = new Set(prev);
      if (on) n.add(id);
      else n.delete(id);
      return n;
    });
  };

  const reset = () => {
    setActiveNodes(new Set());
    setActiveEdges(new Set());
    setPackets([]);
    setModelScores({});
  };

  // Utility delay
  const wait = (ms) => new Promise((res) => setTimeout(res, ms));

  // Create a moving packet between two nodes
  const spawnPacket = (fromId, toId, duration = 800, delay = 0) => {
    const from = nodeMap[fromId];
    const to = nodeMap[toId];
    const { start, end } = getPorts(from, to);
    const id = `${fromId}>${toId}>${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;

    setTimeout(() => {
      setPackets((prev) => [
        ...prev,
        {
          id,
          x: start.x,
          y: start.y,
          toX: end.x,
          toY: end.y,
          progress: 0,
          duration,
          startTime: performance.now(),
        },
      ]);
    }, delay);
  };

  // Animate packets
  useEffect(() => {
    let raf;
    const tick = (t) => {
      setPackets((prev) => {
        const next = [];
        for (const p of prev) {
          const elapsed = t - p.startTime;
          const done = elapsed >= p.duration;
          const prog = Math.min(1, Math.max(0, elapsed / p.duration));
          const x = p.x + (p.toX - p.x) * prog;
          const y = p.y + (p.toY - p.y) * prog;
          if (!done) next.push({ ...p, progress: prog, curX: x, curY: y });
        }
        return next;
      });
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, []);

  // Simulation orchestrator
  const run = async () => {
    if (isRunning) return;
    setIsRunning(true);
    reset();

    // Step 1: Inputs -> Preprocessor -> Distributor
    highlightNode("inputs");
    spawnPacket("inputs", "pre", 800, 150);
    highlightEdge("inputs->pre", true);
    await wait(1000);

    highlightNode("pre");
    highlightEdge("pre->dist", true);
    spawnPacket("pre", "dist", 800, 120);
    await wait(900);

    highlightNode("dist");

    // Step 2: Fan out to models (staggered to read as parallel)
    const models = ["mA", "mB", "mC", "mD", "mE"];
    models.forEach((m, i) => {
      highlightEdge(`dist->${m}`, true);
      spawnPacket("dist", m, 700, i * 120);
    });
    await wait(120 * models.length + 850);

    models.forEach((m) => highlightNode(m));

    // Step 3: Models -> Collector
    models.forEach((m, i) => {
      highlightEdge(`${m}->collector`, true);
      spawnPacket(m, "collector", 700, i * 120);
    });
    await wait(120 * models.length + 850);

    highlightNode("collector");

    // Step 3.5: Compute fake scores
    const rng = (seed) => {
      // Tiny xorshift-ish for repeatable-ish per run. Random enough for demo.
      let x = Math.imul(seed ^ 0x9e3779b9, 0x85ebca6b) >>> 0;
      return () => ((x = (x ^ (x << 13)) ^ (x >>> 17) ^ (x << 5)) >>> 0) / 2 ** 32;
    };
    const r = rng(Date.now() & 0xffff);
    const scores = Object.fromEntries(
      models.map((m) => [m, Math.round(70 + r() * 28)]) // 70–98%
    );
    setModelScores(scores);

    // Step 4: Collector -> Overseer -> Metrics
    highlightEdge("collector->overseer", true);
    spawnPacket("collector", "overseer", 800, 50);
    await wait(900);

    highlightNode("overseer");
    highlightEdge("overseer->metrics", true);
    spawnPacket("overseer", "metrics", 800, 50);
    await wait(900);

    highlightNode("metrics");

    setIsRunning(false);
  };

  const bestModel = useMemo(() => {
    const entries = Object.entries(modelScores);
    if (!entries.length) return null;
    return entries.reduce((a, b) => (a[1] >= b[1] ? a : b));
  }, [modelScores]);

  // Tooltip component
  function Tooltip({ node }) {
    if (!node) return null;
    const pad = 10;
    const left = Math.min(W - 280, Math.max(16, node.x - node.w / 2));
    const top = Math.max(16, node.y - node.h / 2 - 8 - 56);
    return (
      <div
        className="pointer-events-none absolute z-20 max-w-[260px] rounded-xl border bg-white/95 p-3 text-sm shadow-xl"
        style={{ left: left + pad, top: top }}
      >
        <div className="font-medium mb-1">{node.label}</div>
        <div className="text-gray-600">{node.tip}</div>
      </div>
    );
  }

  // Node visual
  const renderNode = (n) => {
    const active = activeNodes.has(n.id);
    const score = modelScores[n.id];
    return (
      <g
        key={n.id}
        className="cursor-pointer"
        onMouseEnter={() => setHovered(n.id)}
        onMouseLeave={() => setHovered((h) => (h === n.id ? null : h))}
      >
        <rect
          x={n.x - n.w / 2}
          y={n.y - n.h / 2}
          rx={16}
          width={n.w}
          height={n.h}
          fill={active ? "#eef2ff" : "#ffffff"}
          stroke={active ? "#4f46e5" : "#cbd5e1"}
          strokeWidth={active ? 2.4 : 1.4}
          className="transition-all"
        />
        <text
          x={n.x}
          y={n.y}
          textAnchor="middle"
          dominantBaseline="central"
          className="select-none fill-gray-800 text-[14px] font-medium"
        >
          {n.label}
        </text>
        {typeof score === "number" && (
          <text
            x={n.x}
            y={n.y + n.h / 2 + 16}
            textAnchor="middle"
            className="select-none fill-gray-600 text-[12px]"
          >
            Acc: {score}%
          </text>
        )}
      </g>
    );
  };

  const renderEdge = (e) => {
    const from = nodeMap[e.from];
    const to = nodeMap[e.to];
    const { start, end } = getPorts(from, to);
    const active = activeEdges.has(e.id);
    return (
      <g key={e.id}>
        <line
          x1={start.x}
          y1={start.y}
          x2={end.x}
          y2={end.y}
          stroke={active ? "#4f46e5" : "#94a3b8"}
          strokeWidth={active ? 2.6 : 1.6}
          markerEnd="url(#arrow)"
          className="transition-all"
        />
      </g>
    );
  };

  return (
    <div ref={containerRef} className="w-full flex items-center justify-center p-6">
      <div className="w-full max-w-[1200px] rounded-2xl border bg-white p-5 shadow-2xl">
        <div className="mb-4 flex items-center justify-between">
          <div className="text-xl font-semibold">AI Evaluation Framework – Interactive Flow</div>
          <div className="flex items-center gap-3">
            {bestModel && (
              <div className="rounded-xl bg-gray-50 px-3 py-1 text-sm text-gray-700 border">
                Best this run: <span className="font-semibold">{nodeMap[bestModel[0]].label}</span> ({bestModel[1]}%)
              </div>
            )}
            <button
              onClick={run}
              disabled={isRunning}
              className="rounded-2xl border px-4 py-2 text-sm font-medium shadow hover:shadow-md disabled:opacity-60"
            >
              {isRunning ? "Running…" : "Run Simulation"}
            </button>
          </div>
        </div>

        <div className="relative">
          {/* Tooltip */}
          <Tooltip node={hovered ? nodeMap[hovered] : null} />

          <svg viewBox={`0 0 ${W} ${H}`} width="100%" height="auto">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8" />
              </marker>
            </defs>

            {/* Edges underneath */}
            {edges.map(renderEdge)}

            {/* Nodes on top */}
            {nodes.map(renderNode)}

            {/* Packets */}
            {packets.map((p) => (
              <circle key={p.id} cx={p.curX ?? p.x} cy={p.curY ?? p.y} r={6} fill="#4f46e5" />
            ))}
          </svg>
        </div>

        <div className="mt-4 grid grid-cols-1 gap-3 md:grid-cols-3">
          <InfoCard title="How it flows" items={[
            "Inputs are normalized and fanned out to every model.",
            "Each model returns a response; collector standardizes the format.",
            "Overseer computes metrics; reports surface winners and failure modes.",
          ]} />

          <InfoCard title="What to hover" items={[
            "Hover any block to get a definition.",
            "Run again to get fresh (fake) scores.",
            "Yes, the arrowheads are judging you.",
          ]} />

          <InfoCard title="What the demo simulates" items={[
            "Packet travel along edges (staggered fan-out).",
            "Highlighting of active nodes/edges.",
            "Randomized accuracy % per model (non-deterministic).",
          ]} />
        </div>
      </div>
    </div>
  );
}

function InfoCard({ title, items }) {
  return (
    <div className="rounded-2xl border p-4 shadow-sm">
      <div className="mb-1 text-sm font-semibold">{title}</div>
      <ul className="list-disc pl-5 text-sm text-gray-700">
        {items.map((it, i) => (
          <li key={i}>{it}</li>
        ))}
      </ul>
    </div>
  );
}
